Box* differentiate_grid_list_and_words(Box* sorted, int n, int* out_count)
{
    if (n <= 0) {
        *out_count = 0;
        return NULL;
    }

    // --- Step 1: Collect all right-edge X positions ---
    double *centers = malloc(n * sizeof(double));
    for (int i = 0; i < n; i++) {
        centers[i] = sorted[i].x + sorted[i].w;  // right edge instead of center
    }

    // --- Step 2: Sort by X ---
    qsort(centers, n, sizeof(double), compare_double);

    // --- Step 3: Compute gaps between centers ---
    double *gaps = malloc((n - 1) * sizeof(double));
    for (int i = 0; i < n - 1; i++) {
        gaps[i] = centers[i + 1] - centers[i];
    }

    // --- Step 4: Find median gap ---
    double median_gap = 0.0;
    if (n > 2) {
        qsort(gaps, n - 1, sizeof(double), compare_double);
        median_gap = gaps[(n - 1) / 2];
    }

    int split_index = n - 1;
    double biggest_gap = 0.0;
    for (int i = 0; i < n - 1; i++) {
        double gap = centers[i + 1] - centers[i];
        if (gap > biggest_gap && gap > median_gap * 1.8) {
            biggest_gap = gap;
            split_index = i;
        }
    }

    double split_x = centers[split_index] + median_gap * 0.5;
    free(centers);
    free(gaps);

    // --- Step 6: Separate into grid and list ---
    Box *grid_boxes = malloc(n * sizeof(Box));
    Box *list_boxes = malloc(n * sizeof(Box));
    int gcount = 0, lcount = 0;

    for (int i = 0; i < n; i++) {
        double right_edge = sorted[i].x + sorted[i].w;
        if (right_edge <= split_x)
            grid_boxes[gcount++] = sorted[i];
        else
            list_boxes[lcount++] = sorted[i];
    }

    // --- Compute bounding boxes for grid and list ---
    Box grid = {INT_MAX, INT_MAX, 0, 0};
    Box list = {INT_MAX, INT_MAX, 0, 0};
    int gx2 = INT_MIN, gy2 = INT_MIN, lx2 = INT_MIN, ly2 = INT_MIN;

    for (int i = 0; i < gcount; i++) {
        Box b = grid_boxes[i];
        if (b.x < grid.x) grid.x = b.x;
        if (b.y < grid.y) grid.y = b.y;
        if (b.x + b.w > gx2) gx2 = b.x + b.w;
        if (b.y + b.h > gy2) gy2 = b.y + b.h;
    }
    grid.w = gx2 - grid.x;
    grid.h = gy2 - grid.y;

    for (int i = 0; i < lcount; i++) {
        Box b = list_boxes[i];
        if (b.x < list.x) list.x = b.x;
        if (b.y < list.y) list.y = b.y;
        if (b.x + b.w > lx2) lx2 = b.x + b.w;
        if (b.y + b.h > ly2) ly2 = b.y + b.h;
    }
    list.w = lx2 - list.x;
    list.h = ly2 - list.y;

        int *word_end = malloc(lcount * sizeof(int));
    int word_count = 0;

    if (lcount > 0) {
        int start = 0;
        for (int i = 1; i < lcount; i++) {
            int same_line = abs((list_boxes[i].y + list_boxes[i].h / 2) -
                                (list_boxes[i - 1].y + list_boxes[i - 1].h / 2)) < 10;
            int close_x = (list_boxes[i].x - (list_boxes[i - 1].x + list_boxes[i - 1].w)) < median_gap * 2.0;

            if (!(same_line && close_x)) {
                word_start[word_count] = start;
                word_end[word_count] = i - 1;
                word_count++;
                start = i;
            }
        }
        word_start[word_count] = start;
        word_end[word_count] = lcount - 1;
        word_count++;
    }

    // --- Step 8: Build the final output array ---
    int total = 2 + word_count;
    Box *result = malloc(total * sizeof(Box));

    result[0] = grid;
    result[1] = list;

    for (int w = 0; w < word_count; w++) {
        int s = word_start[w];
        int e = word_end[w];
        Box wb = {INT_MAX, INT_MAX, 0, 0};
        int x2 = INT_MIN, y2 = INT_MIN;

        for (int i = s; i <= e; i++) {
            Box b = list_boxes[i];
            if (b.x < wb.x) wb.x = b.x;
            if (b.y < wb.y) wb.y = b.y;
            if (b.x + b.w > x2) x2 = b.x + b.w;
            if (b.y + b.h > y2) y2 = b.y + b.h;
        }
        wb.w = x2 - wb.x;
        wb.h = y2 - wb.y;
        result[2 + w] = wb;
    }

    free(grid_boxes);
    free(list_boxes);
    free(word_start);
    free(word_end);

    *out_count = total;
    return result;
}
